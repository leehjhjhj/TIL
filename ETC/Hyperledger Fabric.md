## 하이퍼 레저란?

- Linux Foundation이 주도하는 Hyperledger 프로젝트의 일부
- 기업 환경에 최적화된 블록체인 플랫폼
    - 일반적으로 비트코인, 이더리움과 같은 블록체인은 퍼블릭이지만 Fabric은 `허가형 네트워크 기반` 으로 하기 때문
    - 즉, 네트워크에 참여하는 모든 멤버가 식별 가능하고 관리된다는 뜻
- 또 `채널` 이라는 개념이 있어서 네트워크 내에서 **일부 참여자**들 끼리만 정보 공유 가능 → 같은 회사에서도 다른 부서에게 알려주고 싶지 않은 정보를 감출 수 있다.
- 비지니스 로직은 `체인 코드` 라고 불리는 스마트 컨트렉트를 통해서 구현
    - go, node js, java로 작성이 가능하다.
    - 기존 시스템과의 통합이 용이하며, 블록체인 위에 애플리케이션을 구축하는 것과 비슷함

## 구성요소

### 피어 노드

- Fabric 네트워크의 기본 노드
- 원장 데이터를 저장하고 체인코드를 실행
    - 원장 데이터: 네트워크에서 발생하는 모든 트랜잭션과 현재 상태 정보를 포함하는 전체 기록
    - 블록체인 + 월드 스테이트로 구성되어있다.
        - 블록체인은 말 그대로 암호화된 블록들이 연결되어 한번 기록되면 데이터는 변경할 수 없다.
        - 월드 스테이트는 키-값 데이터베이스로 원장의 현재 상태를 나타낸다. 즉 현재 계좌 잔액 등이 저장된다.
        - 이 둘은 상호 보완적으로 보통 월드스테이트로 정보를 얻으나 필요의 경우 블록체인을 탐색하여 기록을 추적할 수 있다.
        - 월드스테이트는 블록체인의 내용을 정확하게 업데이트 해야하고, 최신상태를 반영해야 함
- `앵커피어`: 조직간 통신의 진입점 역할을 한다. 하나의 조직은 하나 이상의 앵커 피어를 가진다.
- `엔돌싱 피어`: 트랜잭션 제안을 시뮬레이션하고 결과를 승인, 유효한 트랜잭션에 디지털 서명을 제공한다. (잔액 확인 등)
- `커밋팅 피어`: 검증된 트랜잭션 블록을 받아 원장에 추가(원장 업데이트), 모든 피어가 이 역할을 수행.

### 체인코드

- Go, Node.js, Java 등의 언어로 작성된 비지니스 로직
- Docker 컨테이너 내에서 실행된다.

### Orderer 노드

- 트랜잭션의 순서를 결정하고 블록을 직접 생성하는 역할
- 생성된 블록을 모든 피어 노드에 배포한다
- 여러 Orderer 노드 간의 합의를 위해 Raft나 Kafka 알고리즘을 사용할 수 있다.
- 만약에 피어 노드가 여러 개일 때, 거래가 발생하면 Orderer 노드들이 시간 순서대로 정렬을 하고 블록을 만들어서 모든 피어 노드들에게 배포를 한다.
    - 모든 피어가 동일한 순서의 거래 기록을 가질 수 있게 함

### 채널

- 데이터 격리와 프라이버시를 제공하는 private 서브네트워크
- 각 채널은 자체적인 원장을 가진다.
- 특정 멤버들만 참여할 수 있도록 구성된다.
- 예시로는 다국적 은행들이 국제 송금 네트워크를 운영할 때, 각 국가별 또는 지역별로 별도의 채널을 만들어 관련 규제를 준수하면서도 효율적인 운영을 한다.

### 인증 기관

- 앞서 말했듯, 퍼블릭이 아닌 프라이빗 블록체인이기 때문에 인증서가 존재
- Fabric 자체 CA도 사용할 수 있고 상용 CA도 가능

## 거래 과정

1. 클라이언트가 특정 체인 코드 함수를 호출하여 트랜잭션 생성
2. 이 트랜잭션을 채널의 엔돌싱 피어에게 보낸다.
3. 엔돌싱 피어에서는 해당 트랜잭션을 시뮬레이션한다.
    1. 체인코드를 실행하여 검증만 함
4. 시뮬레이션 결과와, 유효하다면 디지털 서명을 클라이언트에게 디지털 서명을 반환한다.
5. 클라이언트는 응답을 검증하고, 트랜잭션을 Orderer 노드에 전송한다.
6. Orderer 노드는 클라이언트로부터 받은 트랜잭션을 시간순서대로 정렬하고 블록으로 묶어 모든 피어에게 전달한다.
7. 피어에서는 받은 블록을 검증하고 피어의 로컬 블록체인에 추가하여 원장 업데이트를 진행한다.
8. 업데이트가 완료되면 피어는 이벤트를 발생시키고 클라이언트는 이 이벤트를 구독하여 트랜잭션 완료를 확인 가능하다.