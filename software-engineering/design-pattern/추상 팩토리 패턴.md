# 팩토리 메서드 패턴

- 여러 스타일(또는 제품군)의 객체를 생성하는데, 각 스타일에 맞는 구체적인 클래스를 직접 코드에 작성하지 않고, 인터페이스를 통해 객체를 생성하게 한다.

![alt text](image/2/image.png)
<sub>출처: refactoring.guru</sub>

- Abstract Product: 개별 연관 제품들의 집합에 대한 인터페이스
- Concrete Product: abstract product의 구현체
- Abstract Factory: Concrete Product를 생성하기 위한 여러 메서드 집합 선언
- Concrete Factory: 추상 팩토리의 생성 메서드들을 구현한다.

## 언제 사용해야 하는가?

- 

![alt text](image/2/image-1.png)


## go 예시 코드

```go
package main

import "fmt"

type Button interface {
    Paint()
}

type Checkbox interface {
    Paint()
}

type WinButton struct {}

func (b *WinButton) Paint() {
    fmt.Println("윈도우 버튼 칠하기")
}

type MacButton struct {}

func (b *MacButton) Paint() {
    fmt.println("맥 버튼 칠하기")
}

type WinCheckbox struct {}

func (c *WinCheckbox) Paint() {
    fmt.Println("윈도우 체크박스 칠하기")
}

type MacCheckbox struct {}

func (c *MacCheckbox) Paint() {
    fmt.println("맥 체크박스 칠하기")
}

type GUIFactory interface {
    CreateButton() Button
    CreateCheckbox() Checkbox
}

type WinFactory struct {}

func (f *WinFactory) CreateButton() Button {
    return &WinButton{}
}

func (f *WinFactory) CreateCheckbox() checkbox {
    return &WinCheckbox{}
}

type MacFactory struct {}

func (f *MacFactory) CreateButton() Button {
    return &MacButton
}

funx (f *MacFactory) CraeteCheckbox() Checkbox {
    return &MacCheckbox
}

type Application struct {
    factory GUIFactory
    button Button
}

func (app *Application) CreateUI() {
    app.button = app.factory.CreateButton()
}

func (app *Application) Paint() {
    app.button.Paint()
}

func main() {
    var factory GUIFactory

    os := "Mac"
    if os == "Windows" {
        factory = &WinFactory{}
    } else if os == "Mac" {
        factory = &MacFactory{}
    } else {
        panic("알 수 없는 운영체제")
    }

    app := &Application{factory: factory}
    app.CreateUI()
    app.Paint()
}
```