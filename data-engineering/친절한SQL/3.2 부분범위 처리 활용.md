# 부분범위 처리 활용

## 부분범위 처리

- 전체 쿼리 결과집합을 쉼 없이 연속적으로 전송하지 않고 사용자로부터 **Fetch Call** 이 있을 때마다 일정량씩 나누어 전송하는 것
    - 쿼리 결과가 100건일 때, Fetch Call 을 통해서 DB에서 10건을 클라이언트 캐시에 저장
    - 그 다음에는 캐시에서 데이터를 읽고, 모두 소진한 상태로 또 부르면 Fetch Call로 10건을 받는다.
- 하지만 `ORDER BY`에 created 같은 컬럼이 있을 경우, 모든 데이터를 읽어서 정렬을 하고나서야 전송이 가능하다.
    - 이럴 때, created 컬럼이 선두인 인덱스가 있으면 부분범위 처리 가능

## Array Size 조정을 통한 Fetch Call 최소화

- 대량의 데이터를 받으려면 Array Size를 크게 설정 -> Fetch Call을 줄일 수 있다.
- 앞쪽 일부 데이터만 Fetch하다 멈추면 작게 설정
    - WAS나 AP 서버 등이 존재하는 n-Tier 아키텍처에는 클라이언트가 특정 DB 커넥션을 독점하지 못한다.
    - 하나의 커넥션 풀에서 SQL 조회 결과를 모두 전송하고 커서를 닫아야 함
    - 5장 3절에서 n-Tier 부분범위 처리 설명

## OLTP 환경에서 부분범위 처리에 의한 성능개선 원리

- 인덱스와 부분범위 처리 원리를 활용하면 OLTP 환경에서 극적인 성능개선 효과를 얻을 수 있다.

```sql
SELECT
    게시글 ID, 제목, 작성자, 등록일시
FROM
    게시판
WHERE
    게시판구분코드 = 'A'
ORDER BY
    등록일시 desc
```

- 여기서 `게시판구분코드` + `등록일시` 로 조합된 인덱스가 존재하지 않으면 sort 연산을 건너띌 수 없다.
- 만약 해당 조합으로 인덱스를 생성하면 Sort 연산 생략이 가능하다.

## 배치 I/O

- 오라클에서 만든 기능
- 원래는 인덱스를 활용해서 테이블을 엑세스하다가 버퍼 캐시에서 블록을 찾지 못하면 디스크 블록에서 바로 읽음
- 근데 이 기능을 활성화하면 테이블 블록에 대한 디스크 I/O Call을 미뤘다가 일정량 쌓이면 한번의 처리
- 버퍼 적중률이 100퍼가 아니면 인덱스 정렬 순서와 다를 수 있다.
    - 그래서 **필요한** Order By를 생략한 SQL은 문제가 될 수 있음