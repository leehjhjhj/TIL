# 인덱스 스캔 효율화

## 인덱스 탐색

![alt text](image/4/image.png)

- 다시 복기하자면, 루트 및 브랜치 블록의 주소로 찾아간 블록에는 **자신의 키 값보다 크거나 같은 값**을 갖는 레코드가 저장
- A3으로 내려가면 자기보다 크거나 같은 리프 블록
- LMC로 내려가면 **키값을 가진 첫 번째 레코드(A3)보다 작거나 같은 값을 갖는다**
- 수직적 탐색은 **스캔 시작점**을 찾는 과정이다.

```sql
WHERE C1 BETWEEN 'A' AND 'C'
AND C2 BETWEEN 2 AND 3
```

- 해당 쿼리의 첫번재 조건절은 시작과 끝을 정해주었기 때문에 도움
- C2는 B구간에서 거의 쓰이지 못했다.
- 시작점을 물론, **끝점** 정해주는 것도 스캔량을 줄이는데 역할을 한다.

## 인덱스 스캔 효율성

![alt text](image/5/image-1.png)

```sql
WHERE c1 = '성'
WHERE c2 = '능'
WHERE c4 = '선'
```

- 해당 SQL이 full scan을 하는 이유는 c4의 인덱스 선행 컬럼인 `c3`에 대한 조건절이 없어서 그런다.
- 인덱스 선행 컬럼이 조건절에 없거나 `=` 조건이 아니면 인덱스 스캔 과정에 비효율 발생

## 엑세스 조건과 필터 조건

- 인덱스 엑세스 조건: 인덱스 스캔 범위를 결정하는 조건
    - 수직적 탐색
    - 스캔 시작점 결정
    - 리프 블록 스캔 후, 어디서 멈출지 결정
- 인덱스 필터 조건: 테이블로 엑세스 할지를 결정하는 조건 절
- 테이블 필터 조건: 쿼리 수행 다음 단계로 전달하거나 최종 결과집합에 포함될지 결정

## 비교 연산자 종류와 컬럼 순서에 따른 군집성

- 인덱스는 `같은 값`을 갖는 레코드들이 서로 군집되어 있음
- 앞에가 모두 `=` 조건일 때, 첫 번째 나타나는 범위검색 조건까지만 만족하는 인덱스 레코드들은 모두 모여있지만, 그 이하 조건까지 만족하는 레코드는 비교 연산자 종류에 상관없이 흩어진다
- 즉, 첫번째 범위 검색까지가 **인덱스 엑세스 조건**, 그 이후는 모두 **인덱스 필터 조건** 이다.

## 인덱스 선행 컬럼이 등치 조건이 아닐 때 생기는 비효율

- 인덱스 선행 컬럼이 `=`일 때, 필요한 범위만 스캔하고 멈출 수 있는 이유 = 조건을 만족하는 레코드가 모두 한데 모여있기 때문
- 따라서 선두 컬럼이 범위 연산자를 사용하면 후의 조건들이 뿔뿔이 흩어지게 된다.

## BETWEEN을 IN-LIST로 전환

- 운영환경에서 인덱스를 바꾸기 쉽지 않다.
- BETWEEN 조건을 IN-List로 바꾸면 큰 효과가 이따.
- 인덱스 수직적 탐색이 N번 발생하게 된다.
    - 수직적 탐색을 하고 `UNION ALL`을 한 것과 마찬가지가 됨
- 개수가 많아지면 NL 조인이나 서브쿼리로 구현하라

### 주의 사항

- IN List 개수가 많지 않아야 한다.
- 루트에서 브랜드 블록까지 Depth가 깊어지면 수직적 탐색이 많아질 수록 안좋다.
- 따라서 In list 절 이후의 조건이 서로 가까이 있다면 굳이 In-List로 바꿔서 수직적 탐색을 늘릴 필요가 없다.