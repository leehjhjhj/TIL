# 인덱스 스캔 효율화

## 인덱스 탐색

![alt text](image/4/image.png)

- 다시 복기하자면, 루트 및 브랜치 블록의 주소로 찾아간 블록에는 **자신의 키 값보다 크거나 같은 값**을 갖는 레코드가 저장
- A3으로 내려가면 자기보다 크거나 같은 리프 블록
- LMC로 내려가면 **키값을 가진 첫 번째 레코드(A3)보다 작거나 같은 값을 갖는다**
- 수직적 탐색은 **스캔 시작점**을 찾는 과정이다.

```sql
WHERE C1 BETWEEN 'A' AND 'C'
AND C2 BETWEEN 2 AND 3
```

- 해당 쿼리의 첫번재 조건절은 시작과 끝을 정해주었기 때문에 도움
- C2는 B구간에서 거의 쓰이지 못했다.
- 시작점을 물론, **끝점** 정해주는 것도 스캔량을 줄이는데 역할을 한다.

## 인덱스 스캔 효율성

![alt text](image/5/image-1.png)

```sql
WHERE c1 = '성'
WHERE c2 = '능'
WHERE c4 = '선'
```

- 해당 SQL이 full scan을 하는 이유는 c4의 인덱스 선행 컬럼인 `c3`에 대한 조건절이 없어서 그런다.
- 인덱스 선행 컬럼이 조건절에 없거나 `=` 조건이 아니면 인덱스 스캔 과정에 비효율 발생

## 엑세스 조건과 필터 조건

- 인덱스 엑세스 조건: 인덱스 스캔 범위를 결정하는 조건
    - 수직적 탐색
    - 스캔 시작점 결정
    - 리프 블록 스캔 후, 어디서 멈출지 결정
- 인덱스 필터 조건: 테이블로 엑세스 할지를 결정하는 조건 절
- 테이블 필터 조건: 쿼리 수행 다음 단계로 전달하거나 최종 결과집합에 포함될지 결정

## 비교 연산자 종류와 컬럼 순서에 따른 군집성

- 인덱스는 `같은 값`을 갖는 레코드들이 서로 군집되어 있음
- 앞에가 모두 `=` 조건일 때, 첫 번째 나타나는 범위검색 조건까지만 만족하는 인덱스 레코드들은 모두 모여있지만, 그 이하 조건까지 만족하는 레코드는 비교 연산자 종류에 상관없이 흩어진다
- 즉, 첫번째 범위 검색까지가 **인덱스 엑세스 조건**, 그 이후는 모두 **인덱스 필터 조건** 이다.