# 테이블 엑세스 최소화

## 테이블 랜덤 엑세스

- 데이터가 아무리 많아도 인덱스를 사용하면 데이터가 금방 조회된다.
- 하지만 대량 데이터를 조회할 때는 table full scan보다 느리다.

### 인덱스 ROWID는 물리적 주소? 논리적 주소?

- 실행 계획에서 `TABLE ACCESS BY INDEX ROWID`는 인덱스 스캔 뒤 테이블 엑세스라는 뜻
- 인덱스를 스캔하는 이유 = 소량의 데이터를 인덱스에서 빨리 찾고, 테이블 레코드를 찾아가기 위한 주소값 `ROWID`를 얻기 위함
- ROWID는 포인터와 비슷하지만 물리적 주소가 아니라 논리적 주소이다.
- ROWID는 포인터(메모리 주소 정보)가 아니기 때문에 디스크 주소 정보를 이용해 **해시 알고리즘**으로 버퍼 블록을 찾는다.

### I/O 메커니즘 복습

- 버퍼캐시를 사용해야 성능이 좋아짐
- 해싱 알고리즘으로 버퍼 헤더를 찾고, 거기서 얻은 포인터로 버퍼 블록을 찾음
- ROWID가 가르키는 테이블 블록을 버퍼캐시에서 먼저 찾고, 없으면 디스크에서 찾는다.
- 즉, 모든 데이터가 캐싱이 되어있어도 무조건 버퍼캐시를 거치고, DBA해싱과 래치 획득과정 반복이 필요

> 메인메모리 DB의 포인터는 전화번호
> 인덱스 ROWID는 우편주소

## 인덱스 클러스터링 팩터(CF)

- `군집성 계수(CF)`, 특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도
- CF가 좋은 컬럼에 생성한 인덱스는 검색 효율이 좋다. 이유는 블록 I/O가 적게 발생하기 때문
    - `버퍼 Pinning`이 찾아간 데이트 블록의 포인터를 해제하지 않고 유지하기 때문

## 인덱스 손익분기점

- Index Range Scan에 의한 테이블 엑세스가 Table Full Scan보다 느려지는 지점을 말한다.
- 그렇다면 왜 느려지는가?
    - Table Full Scan은 시퀀셜 엑세스, 하지만 인덱스 ROWID는 랜덤 엑세스 방식
    - Table FUll Scan은 Multiblock I/O, 인덱스 ROWID는 Single Block I/O