# 인덱스 기본 사용법

## 인덱스를 사용한다는 것

- 인덱스를 정상적으로 사용한다 = 리프 블록 일부만 스캔하는 `Index Range Scan`을 의미
- 인덱스 컬럼을 가공하지 않아야 한다

## 인덱스를 Range Scan 할 수 없는 이유

- 인덱스 컬럼을 가공했을 때 정상적으로 사용할 수 없는 이유는 **인덱스 스캔 시작점을 찾을 수 없기 때문** 이다.
- Range를 사용하려면 시작점과 끝지점이 있어야 한다.

```sql
where nvl('주문수량', 0) < 100
```

```sql
where ('전화번호' = :tel_no OR '고객명' = :cust_num)
```

- 어느 한 시작지점을 바로 찾을 수 없다.
- 이 두 경우 인덱스 스캔 시작점을 알 수 없다.

```sql
where '전화번호' in (:tel_no1, :tel_no2)
```

- IN 조건은 OR 조건을 표현하는 다른 방식이다.
- 그래서 옵티마이저는 IN의 LIST 개수 만큼 Index Range Scan을 반복한다. 이를 통해 밑과 같은 효과를 낸다

```sql
select *
from '고객'
where '전화번호' = :tel_no
union all
select *
from '고객'
where '전화번호' = :tel_no2
```

## 더 중요한 건 인덱스 사용 조건

- 인덱스를 [소속팀 + 사원명 + 연령] 순으로 구성한다는 것은 데이터를 소속팀이 같으면 사원명으로, 사원명이 같으면 연령순으로 정렬한다는 뜻
- 즉 where절에 `사원명 = 홍길동` 이 오게되면 리프 블록 전역에 흩어진 홍길동을 찾아야한다.
- Range Scan을 하기위한 첫번째 조건ㅇ느 **인덱스 선두 컬럼이 조건절에 있어야 한다** 이다.

### 인덱스 잘 타니깐 튜닝 끝?

- 실행계획을 잘 살펴보고, range scan을 하는지 확인만해서는 안된다.
- 인덱스 리프 블록에서 스캔하는 양을 따져봐야한다.

## 인덱스를 이용한 소트 연산 생략

- pk 인덱스를 스캔하면서 출력한 결과집함은 어차피 정렬되어 있기 때문에 order by를 해도 실행계획은 똑같다.
- DESC도 마찬가지, 리프 블록은 **양방향 연결 리스트 구조**이기 때문에 가능하다

## ORDER BY 절에서 컬럼 가공

- 조건절이 아닌 `ORDER BY` 또는 `SELECT-LIST` 에서 컬럼을 가공해서 인덱스를 정상적으로 사용할 수 없는 경우도 존재한다.

```sql
SELECT *
FROM 상태변경이력
WHERE 장비번호 = 'C'
ORDER BY 변경일자 || 변경 순번
```

- 장비번호, 변경일자, 변경순번 순으로 구성했어도 가공한 값을 기준으로 정렬해달라 했기 때문에 정렬 연산 생략 불가능

```sql
SELECT *
FROM (
    SELECT TO_CHAR(A.주문번호, 'FM000000') AS 주문번호
    FROM 주문 A
    WHERE A.주문일자 = :dt
    AND 주문번호 > NVL(:next_ord_no, 0)
    ORDER BY 주문번호
)
WHERE ROWNUM <= 30
```

- 주문일자, 주문번호로 구성했어도 SELECT절에 가공된 주문번호로 정렬을 요청했기 때문에 안됨
- 그래서 `ORDER BY A.주문번호`로 바꿔주면 SORT ORDER BY를 생략 가능

## SELECT-LIST에서 컬럼 가공

- 장비번호, 변경일자, 변경순번 순으로 되어있을 때

```sql
SELECT NVL(MAX(TO_NUMBER(변경순번)), 0)
```

- 인덱스는 문자열 기준으로 되어있는데 숫자로 SELECT이 되기 때문에 정렬 연산 생략 불가능

```sql
SELECT NVL(TO_NUMBER(MAX(변경순번)), 0)
```

- 이렇게 바꿔준다.

## 자동 형변환

- 생년월일 컬럼이 문자형인데 조건절 비교값을 숫자형으로 하면 `IN_NUMBER`로 자동 형변형이 되어 Range Scan이 불가능
- 특히 `LIKE` 절은 `TO_CHAR`로 자동 형변형을 해주기 때문에 주의 
- 자동 형변환으로 성능과 품질에 종종 문제가 생긴다.
    - SQL의 성능은 `블록IO`를 줄이는 것이기 때문에 형 변환을 생략하지 않아도되고, 오히려 명시하는 것이 더 좋다.
    - 연산횟수를 줄인다고 생갹하여도 옵티마이저가 자동으로 생성한다.