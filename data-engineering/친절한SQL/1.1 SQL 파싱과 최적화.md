# 1.1 SQL 파싱과 최적화

- SQL은 기본적으로 `구조적`이고 `집합적`, 그리고 `선언적`인 질의 언어
- 그런데 결과 집합을 만드는 것은 절처적, 즉 **프로시저**가 필요 -> 프로시저를 만들어 내는 것이 SQL 옵티마이저
- `사용자` SQL -> `옵티마이저` 실행계획 -> `프로시저`

## SQL 최적화

- SQL 파싱
    - 파싱 트리 생성
    - Syntax 체크
    - Semantic 체크
- SQL 최적화
    - 옵티마이저가 가장 효율적인 실행경로를 선택
- 로우 소스 생성
    - 실행경로를 실제 실행 가능한 코드 또는 프로시저 형태로 포매팅

## SQL 옵티마이저

- 옵티마이저 최적화 단계
    - 쿼리를 수행하는데 후보군의 실행계획 찾기
    - 데이터 딕셔너리를 통해서 실행계획의 예상비용 산정
    - 최저 비용 실행계획 선택

## 실행 계획과 비용

- `SQL 실행 경로 미리보기` = `실행계획`
- 이를 통해서 테이블을 스캔하는지, 인덱스를 스캔하는지 알 수 있다.
- `cost` 는 쿼리를 수행하는 동안 발생할 것으로 예상되는 IO 횟수 or 예상 소요 시간
- 하지만 이도 언제까지나 예상치이다.

## 옵티마이저 힌트

- 개발자가 더 효율적인 액세스 경로를 지정

```sql
SELECT /* INDEX(A 고객_PK) */
    고객명, 연락처, 주소, 가입일시
FROM 고객 A
WHERE 고객ID = '0000008'
```

- 주의 사항
    - 힌트와 힌트 사이에는 `,` 를 사용하지 말 것
    - 스키마 명까지 명시하지 말 것
    - FROM 절에 alias를 사용했다면 힌트에도 alias를 사용할 것

- 힌트는 강제해도 되고, 나머지는 옵티마이저에게 맡겨도 된다.