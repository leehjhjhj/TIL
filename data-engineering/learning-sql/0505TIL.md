# 인덱스
## 고유 인덱스
- 일반 인덱스 이점 + 인덱스 열에 중복값을 허용하지 않는다.
```SQL
ALTER TABLE customer
ADD UNIQUE idx_email (email);
```
## 다중 열 인덱스
- 두 개의 열을 사용해서 인덱스를 생성
- 인덱스를 거는 순서가 중요하다. 성, 이름으로 걸어놨으면 성 또는 성, 이름으로 검색할 때만 효율이 좋다.

## B-tree 인덱스
- 균형 트리 인덱스
- 서버는 트리의 균형을 유지해서 빠르게 리프 노드로 이동 가능

## 비트맵 인덱스
- B-tree 인덱스는 `is_active`와 같이 0과 1의 두 개의 값만 있을 때 불리함
- low-cardinality 를 가진 데이터의 경우 비트맵 인덱스 사용 - only oracle

## 텍스트 인덱스
- mysql에서는 full-text index, 오라클은 oracle index

## 어떤 인덱스가 가장 효율적인가?
- `EXPLAIN` 을 사용한다. 쿼리 옵티마이저가 어떤 인덱스를 선택하였는지 보여준다.

## 인덱스의 단점
- 인덱스도 결국 테이블이기 때문에 삭제, 변경을 할 때 인덱스 테이블도 수정된다.
### 필요한 인덱스 개수 팁
- 모든 기본 키 열에 인덱스가 있는지 확인
- 다중 열 기본 키의 경우 기본 키 열에서 기본 키 제약 조건 정의와 다른 순서도 고려 가능
- 외래 키 제약조건은 모두 인덱스
- 데이터 검색에 자주 사용되는 열을 인덱싱. 대부분의 **날짜 열**은 2~50자의 짧은 문자열과 함께 인덱스로 good

# 제약조건
- 테이블의 하나 이상의 열에 적용되는 제한사항
    - 기본 키 제약
    - 외래 키 제약
    - 고유 제약 조건: 테이블 내에서 고유한 값을 포함하도록 하나 이상의 열을 제한
    - 체크 제약 조건: 열에 허용되는 값을 제한
- 기본 키와 외래 키 제약조건이 있으면 다른 테이블에서 참조하는 데이터를 수정, 삭제하려 할 때 오류 발생
## 제약 조건 생성
- `on delete restrict`: 부모 테이블에서 행을 삭제하면 서버에서 오류 발생
- `on update cascade`: 부모 테이블에서 기본 키 값에 대한 변경 사항을 자식 테이블로 전파
- `on delete cascade`
- `on update restrict`
- `on update set null`: 부모 테이블에서 행이 삭제되거나 업데이트 될 때 자식 테이블의 외래 키 값을 `null`로 설정